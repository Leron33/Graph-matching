% comparison of 1-hop algorithm, 2-hopalgorithm and NoisySeeds algorithm
% applied to the SHREC’16 dataset, with initial noisy seeds generated by
% the GRAMPA algorithm.
%% PREPARE
clear all;
path_kids = '';          % path to the complete TOPKIDS data set
track = 'low resolution/';  % low or high resolution
%% CALCULATE CURVES

thresholds = 0:0.01:0.25;
% calculate kims curves
curve_init=zeros(90,length(thresholds));
curve1 = zeros(90,length(thresholds));
curve2 = zeros(90,length(thresholds));
curven1 = zeros(90,length(thresholds));
curven2 = zeros(90,length(thresholds));
curven3 = zeros(90,length(thresholds));
for k=1:90
    k
    i=ceil(k/9);
    j=k-(i-1)*9;
    if j<i
        j=j+15;
    else
        j=j+16;
    end
    i=i+15;
    %% load data
    
    M = load_off(strcat(path_kids,track, 'kid', num2str(i,'%02d'), '.off'));
    N = load_off(strcat(path_kids,track, 'kid', num2str(j,'%02d'), '.off'));
    
    V1=M.VERT;                  % 3-d coordinates of vertices
    F1=M.TRIV;                  % face for triangulation
    V2=N.VERT;
    F2=N.TRIV;
    
    adj1 = triangulation2adjacency(M.TRIV);     % adj after triangulation
    adj2 = triangulation2adjacency(N.TRIV);
    distances=geodesic_distance(N.TRIV,N.VERT); %Added by JX
    distances=sparse(distances);
    n1=size(adj1,1);
    n2=size(adj2,1);
    
    EYE1=sparse(1:n1,1:n1,1,n1,n1);
    EYE2=sparse(1:n2,1:n2,1,n2,n2);
    W21=double((double((adj1*adj1)>0)-adj1-EYE1)>0);
    W22=double((double((adj2*adj2)>0)-adj2-EYE2)>0);
    
    %% grampa
    grampa;
    P_sp = greedy_match(X);
    if n1<=n2
        init_idx1 = [1:size(adj1,1)]';
        idx2=1:size(adj2,1);
        init_idx2 = P_sp*idx2';   %contains nodes in adj2 corresponding to node i in adj1
        %visualization
%            PlotResultAfterLocalMinimization(V1',F1',V2',F2',init_idx1,init_idx2,'source','target');
    else
        init_idx2=[1:size(adj2,1)]';
        idx1=1:size(adj1,1);
        init_idx1=P_sp'*idx1';
%            PlotResultAfterLocalMinimization(V1',F1',V2',F2',init_idx1,init_idx2,'source','target');
    end
    %visualization
%     V1=V1';V2=V2';F1=F1';F2=F2';
%     colorVerts = V1(:,init_idx1)';
%     scattColor = bsxfun(@rdivide,bsxfun(@minus,colorVerts,min(colorVerts,[],1)), (max(colorVerts,[],1)-min(colorVerts,[],1)));
%     figure('units','normalized','position',[0 0 0.5 0.5]);
%     %[ha, pos]=tight_subplot(1,2,0,0.01,0.01);
%     subplot(1,3,1)
%     title('source','FontSize',20)
%     params.scattColor = scattColor;
%     params.verInd  = init_idx1;
%     plotMeshAndPoints( V1, F1, params )
%     %axes(ha(1));
%     subplot(1,3,2)
%     title('results of GRAMPA','FontSize',20)
%     params.scattColor = scattColor;
%     params.verInd  = init_idx2;
%     plotMeshAndPoints( V2, F2, params )
    %% Read ground truth
    gt_M_null = read_correspondence(strcat(path_kids, track, 'kid', num2str(i), '_ref.txt'));
    gt_N_null = read_correspondence(strcat(path_kids, track, 'kid', num2str(j), '_ref.txt'));
    gt = merge_ground_truth(gt_M_null, gt_N_null);
    
    
    
    corr_init=[init_idx1,init_idx2];
    errors_init = zeros(size(corr_init,1), 1);
    
    for m=1:size(corr_init,1)
        
        if (strcmp(track, 'low resolution/'))
            gt_match = gt(gt(:,1) == corr_init(m,1), 2);
            match = corr_init(m,2);
            
            if ~isempty(gt_match)
                % using the geodesic distance of the second graph
                errors_init(m) = distances(gt_match, match); % TODO include your geodesics here
            else
                errors_init(m) = 200;
            end
        else
            errors_init(m) = 100;
        end
        
    end
    
    diameters = sqrt(sum(calc_tri_areas(N)));
    errors_init = errors_init / diameters;
    for m=1:length(thresholds)
        curve_init(k,m) = 100*sum(errors_init <= thresholds(m)) / length(errors_init);
    end
    
    P_rnd=zeros(n2,n1);
    for ind=1:length(gt(:,1))
        P_rnd(gt(ind,2),gt(ind,1))=1;
    end
    P_rnd=sparse(P_rnd);
    
    corr_sp=full(sum(dot(P_rnd,P_sp'))/length(errors_init));
    %% 1-hop
    iter_max=100;
    
    
    r_old=corr_sp;
    S=P_sp';
    
    for iter_count=1:1:iter_max
        X=adj2*S*adj1;
        [S,] = greedy_match(X);
        r=full(sum(dot(P_rnd,S))/length(errors_init));
        if abs(r-r_old) <1e-6  %convergence criterion
            break;
        end
        r_old=r;
    end
    
    if n1<=n2
        final_idx1 = [1:n1]';
        idx2=1:n2;
        final_idx2 = S'*idx2';
        %        PlotResultAfterLocalMinimization(V1',F1',V2',F2',final_idx1,final_idx2,'source','target');
    else
        final_idx2=[1:n2]';
        idx1=1:n1;
        final_idx1=S*idx1';
        %        PlotResultAfterLocalMinimization(V1',F1',V2',F2',final_idx1,final_idx2,'source','target');
    end
    corr=[final_idx1,final_idx2];
    
    errors = zeros(size(corr,1), 1);
    
    for m=1:size(corr,1)
        
        if (strcmp(track, 'low resolution/'))
            gt_match = gt(gt(:,1) == corr(m,1), 2);
            match = corr(m,2);
            
            if ~isempty(gt_match)&& match>0
                % using the second graph
                errors(m) = distances(gt_match, match); % TODO include your geodesics here
            else
                errors(m) = -2;
            end
        else
            errors(m) = -1;
        end
        
    end
    diameters = sqrt(sum(calc_tri_areas(N)));
    errors = errors / diameters;
    for m=1:length(thresholds)
        curve1(k,m) = 100*sum(errors <= thresholds(m)) / length(errors);
    end
    %% 2-hop
    r_old=corr_sp;
    S=P_sp';
    
    for iter_count=1:1:iter_max
        X=W22*S*W21;
        [S,] = greedy_match(X);
        r=full(sum(dot(P_rnd,S))/length(errors_init));
        if abs(r-r_old) <1e-6  %convergence criterion
            break;
        end
        r_old=r;
    end
    
    if n1<=n2
        final_idx1 = [1:n1]';
        idx2=1:n2;
        final_idx2 = S'*idx2';
%                PlotResultAfterLocalMinimization(V1',F1',V2',F2',final_idx1,final_idx2,'source','target');
    else
        final_idx2=[1:n2]';
        idx1=1:n1;
        final_idx1=S*idx1';
%                PlotResultAfterLocalMinimization(V1',F1',V2',F2',final_idx1,final_idx2,'source','target');
    end
%     subplot(1,3,3)
%     title('results of 2-hop','FontSize',20)
%     params.scattColor = scattColor;
%     params.verInd  = final_idx2;
%     plotMeshAndPoints( V2, F2, params )
%     %axes(ha(2));
%     %set(gcf,'Position',[100, 100, 800, 800]);
%     pos = get(gca, 'Position');
%     pos(1) = 0.4;
%     set(gca, 'Position', pos)
%     set(gcf,'color','w');
    
    corr=[final_idx1,final_idx2];
    
    errors = zeros(size(corr,1), 1);
    
    for m=1:size(corr,1)
        
        if (strcmp(track, 'low resolution/'))
            gt_match = gt(gt(:,1) == corr(m,1), 2);
            match = corr(m,2);
            
            if ~isempty(gt_match)&& match>0
                % using the second graph
                errors(m) = distances(gt_match, match); % TODO include your geodesics here
            else
                errors(m) = 200;
            end
        else
            errors(m) = 100;
        end
        
    end
    diameters = sqrt(sum(calc_tri_areas(N)));
    errors = errors / diameters;
    for m=1:length(thresholds)
        curve2(k,m) = 100*sum(errors <= thresholds(m)) / length(errors);
    end
    %% NoisySeed
    r_old=corr_sp;
    S=P_sp';
    pi_n1=zeros(1,n1);
    pi_n2=zeros(1,n2);
    for iter_count=1:1:iter_max
        r1=2-0.1;
        flag=1;
        while (flag)
            flag=0;
            X=adj2*S*adj1;
            [pos_i,pos_j]=find(X>r1);
            for m=1:length(pos_i)
                if pi_n1(pos_j(m))==0&&pi_n2(pos_i(m))==0
                    flag=1;
                    pi_n2(pos_i(m))=pos_j(m);
                    pi_n1(pos_j(m))=pos_i(m);
                end
            end
            pi_h=pi_n2;
            ind=[1:n2];
            ind(pi_h==0)=[];
            pi_h(pi_h==0)=[];
            S=sparse(ind,pi_h,1,n2,n1);
        end
        r=full(sum(dot(P_rnd,S))/length(errors_init));
        if abs(r-r_old) <1e-6  %convergence criterion
            break;
        end
        r_old=r;
    end
    
    if n1<=n2
        final_idx1 = [1:n1]';
        idx2=1:n2;
        final_idx2 = S'*idx2';
        %        PlotResultAfterLocalMinimization(V1',F1',V2',F2',final_idx1,final_idx2,'source','target');
    else
        final_idx2=[1:n2]';
        idx1=1:n1;
        final_idx1=S*idx1';
        %        PlotResultAfterLocalMinimization(V1',F1',V2',F2',final_idx1,final_idx2,'source','target');
    end
    corr=[final_idx1,final_idx2];
    
    errors = zeros(size(corr,1), 1);
    
    for m=1:size(corr,1)
        
        if (strcmp(track, 'low resolution/'))
            gt_match = gt(gt(:,1) == corr(m,1), 2);
            match = corr(m,2);
            
            if ~isempty(gt_match)&& match>0
                % using the second graph
                errors(m) = distances(gt_match, match); % TODO include your geodesics here
            else
                errors(m) = 200;
            end
        else
            errors(m) = 100;
        end
        
    end
    errors = errors / diameters;
    for m=1:length(thresholds)
        curven1(k,m) = 100*sum(errors <= thresholds(m)) / length(errors);
    end
   
end

%% FIGURE
% h = openfig('./low_resolution.fig');
figure;hold on;
plot(thresholds', mean(curve2, 1)'), ylim([0 100]);
plot(thresholds', mean(curve1, 1)'), ylim([0 100]);
plot(thresholds', mean(curven1, 1)'), ylim([0 100]);
plot(thresholds', mean(curve_init, 1)'), ylim([0 100]);
legend('2-hop','1-hop','NoisySeeds r=2','GRAMPA');
line_width=1.5;
hline = findobj(gcf, 'type', 'line');
set(hline,'LineWidth',line_width);
% savefilename='grampa_low_resolution';
% saveas(gcf, savefilename, 'fig');